#include"quarks.h"
#include<stdio.h>
#include<math.h>
#include"myMath.h"
#define M_PI 3.14159265358979323846
//the quark will be defined then it will be used to generate the math in the matrix in which i will be using
//the matrix will be a 2d to use them time 
void **quarkConfimentPrinicpal(int n, float energy,float i ){
	int j,k;
	n =0;
	int *alpha, beta, m;
	int ** U, t, deltai;
	float a, b,delta, capdelta;
	while(n >= 4)
	{
		for (j =0; j <= U[n][k]; j++)
		{
			for (k =0 ; k <= U[j][n]; k++)
			{
			        1=abs(powf(U[j][k],2));
				U[i][j]=expf(i(alpha[j] + beta[k])*U[j][k]);
				if (U[j][k] == U[k][j]) 
				{
					if (U[j][j] > 0) 
				
					{
						U[j][k]= expf(i(M_PI(m[j]+m[k])*U[j][k]);
						if (m[j] = 0) //this line is trying to find any combination that has m[j] = 0 and will replace it with a binary operator of 0 
						{
							U[j] |= 0;
					
						} else if ( m[j] = 1)// this line also combines the operator of 1 
						{
							U[j] |= 1;
						}
						if(-M_PI/2 < delta[1][k] && <= M_PI/2 ||  k >2 ) //this one allow the operater to be determine what pi is and how far out k has a value
						{ 
							U[1][k] = i*abs(U[1][k] *exp(i*delta*1k)i;
						}
					}
				}
				U = 1 = 2*i*t;
			       if( t < 1/ sqrt(2)) 
			       {
			       capdelta = -i(capdelta*t + t*capdelta);
			       2*capdelta =2*capdelta(t*t + t*t);
			       	if ( 2* capdelta <= 2* capdelta(t*t + t*t) <=4 capdelta *t^2;
			       	{
					if (t => 1 / sqrt(2) || capdelta = 0)
					{
						bc =0;
						b= i*sqrt(c*c + 1);
				       		c= i*sqrt(b*b + 1);
						T= 1/2i[sqrt(1+sqrt(b*b(1+c*c) - ((bc)(bc))))];
						if (t = 1/sqrt(2) || approach(b,0) || b*c !=0)
						{
							if (t[j][k] == t[k][j] || deltai[j][k] == deltai[k][j])
			       				{ 
							       T[j][k] = t[j][k] * exp(i* deltai[j][k];
							}
							delta[j][j] =M_PI/2;
							U[j][j]= 1 - 2*t[j][j];
							if (0 < t[j][j]  && t[j][j] < 1/2 && j != k) 
							{
							if (-M_PI/2 < deltai[j][k] && deltai[j][k] <= M_PI/2 && t[1][k] > 0 && t[j][k] != 1)
							{

							t[j][j] = 1/2(1-abs(U[j][j]));
							t[j][k] = 1/2*abs(U[1][k]);
							if ( 2 <= j && j < K && k <= n)
							{
							t[j][k] = 1/2* abs(U[j][k];
									}
									for (l = 0; l < n; l++)
									{
									float condition = sin(deltai[j][k]);
											if (1 <= j && j<= k && k < = n )
											t[j][k]=(t[j][l]*t[k][l]* cos( delta[j][l] -delta[k][l]))/condition;
										       if(t[j][j] == t[k][k]) {
										       }
									if(t[j][j] != t[j][k] || k != j){
							 t[j][j] = 1/2 -1/2*sqrt(1-4*t[j][k]*t[j][k]);
					 if(1<=j && j < k && k <= n) {
			float cond = (1-t[j][j]-t[k][k])sin(deltai[j][k];
		        t[j][k] = t[j][l]* t[k][l]* cos(deltai[j][l] - deltai[k][l])/cond;
		       }
		       }
		       }		       
						}
					}
				 }
				}
		}
			n++;
	}
	while(n <= 4 || energy<= 45)
       	{
		if (energy => 45.0 && energy <= 90.0)
		{

		}
	}

}
float ** upQuark(float spin, float rotation,float energy){
}
float ** downQuarks(float spin, float rotation, float energy){
}
float ** strangeQuarks(){
}
float ** charmQuarks(){
}
float ** topQuarks(){
}
float ** botQuarks(){
int main() {
	println(" if the " , quarkConfinementPrinipical(3,260.00,-.293450);
}	

